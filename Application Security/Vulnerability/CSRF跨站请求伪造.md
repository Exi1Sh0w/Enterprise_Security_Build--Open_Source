
# CSRF（Cross-site request forgery）跨站请求伪造

## 0x00 简要介绍

CSRF（Cross-site request forgery）跨站请求伪造，是指攻击者通过伪装来自受信任用户的请求来利用受信任的站点，强制对已完成认证的用户进行非预期的个人信息或设定信息等某种状态更新，也就是说攻击者盗用了你的身份，以你的名义发送恶意请求。

攻击者迫使web应用的用户去执行攻击者预设的操作，如果服务器没有合适的防御措施，用户即使访问熟悉的可信网站（生成poc可以隐藏到论坛/blog等用户生成内容的网站中）也有受到攻击的危险

攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏器，让其以用户的名义执行操作。

因此对于用户来说很难避免在登陆一个网站之后不点击一些链接进行其他操作，所以随时可能成为CSRF的受害者。

检测csrf漏洞一般是看每一个操作是否有验证码验证，是否有token或者referer,可以注册多个账户然后利用A用户生成的poc去检测B用户，poc可以通过burpsuite去生成

## 0x01 防御方案

在web站点，将持久化的授权（例如cookie或者http授权）切换为瞬时的授权方法（在每个form中提供隐藏field）；
- 验证码，强化用户与应用的交互，但每个请求都加验证码，用户友好性体验差，不适合实际使用；
- 在HTTP头中自定义属性并验证 + One time tokens；
- 检查请求header中的referer也能帮助组织CSRF攻击，但服务器不是总能拿到referer，有些浏览器出于安全会隐私考虑会不发referer，所以也不常用； 
- 在浏览其它站点前退出登录站点或者浏览结束后清理浏览器cookies；
- 不同的表单包含一个随机的token，在用户提交数据的同时提交这个token，服务器端对比后如果不正确，则拒绝执行操作。
    这里是对token的建议如果是已登录的界面给予建议：在前端生成含有 **用户id|当前时间|当前用户ip**可逆的组合加密项(注意是加密不是编码，切忌不要用base64等常见编码当加密措施)，然后后端接收到token然后解密并验证用户ID是否与当前cookie中的用户id一致、用户当前IP是否一致、用户提交的时间与当前时间间隔，如果差距在30分钟以上那么需要用户重新刷新表单提交。

    首先当用户第一次访问页面的时候，服务端可以获取到用户的ID、用户的当前IP、当前用户访问的时间等一些相关信息，利用这些信息组合做一个可逆向的加密，返回给前端，在前端生成一个input  hidden项 name为token，直接放入 value，如果用户执行页面的一些操作Get、Post等请求，会自动带上此值，然后服务端解密此值，然后在与当前获取的同样的数据做判断。

### Token

1. 前后端未分离

    前后端未分离的情况，token防御的整体思路是：

    1. 后端随机产生一个token，把这个token保存在SESSION状态中；同时，后端把这个token交给前端页面；
    1. 下次前端需要发起请求（比如发帖）的时候把这个token加入到请求数据或者头信息中，一起传给后端；
    1. 后端校验前端请求带过来的token和SESSION里的token是否一致；

    有兴趣的朋友可以看看DVWA里的CSRF，前后端未分离，防御方法就是上面的方法。并且我发现阿里云的很多应用也是采用SESSION的方式。

2. 前后端分离

    我们前端架构早已经告别了服务端语言（PHP/JAVA等）绑定路由、携带数据渲染模板引擎的方式。当然，前端不要高兴的太早，前后端分离之后，Nodejs不具备完善的服务端SESSION、数据库等功能。

    就目前来看，大量的公司对外的应用都是前后端分离。所以在前后端分离的情况下，上文提到的防御方案已经无法实现。但是我们可以借助Cookie把这个升级下，通过Cookie进行浏览器和服务端的交互。防御思路是：

    1. 后端随机产生一个token
    1. 后端将这个token设置为cookie，返回给前端
    1. 前端需要发起请求的时候，从cookie中获取token，把这个token加入到请求数据或者头信息中，一起传给后端。由于前段要获取cookie里的token，所以该token必须设置为非httponly
    1. 后端校验$_COOKIES['token'] == $_POST['token']

    在这种防御方案下，攻击者构造一个CSRF页面，由于不知道被攻击者Cookie中的token字段的值，导致无法构造$_POST['token']参数。所以，攻击失败。


    相比于吧token存在session中会造成大量资源浪费，基于cookie的csrf防御方法有如下有点：
    
    
    1. 无需使用Session，适用面更广，适合“Secure By Default“原则。
    1. Token储存于客户端中，不会给服务器带来压力。
    1. 没有其他漏洞的情况下，黑客无法接触Cookie，所以保证了Token的机密性，也就可以防御CSRF漏洞。

    基于Cookie的CSRF防御机制也会存在安全隐患，当存在XSS的时候，读取Cookie里的token，将token带到POST请求里，即可绕过。或利用其他漏洞（crlf漏洞等）写cookie，覆盖原来的cookie


3. 总结

- CSRF的token存在Cookie里的方式，如果存在XSS，必定会被绕过。因为前端要获取Cookie里的token，该字段必须设置为非httponly，否则获取不到。
- 用Referer限制防御CSRF存在XSS也会被绕过。
- 通过$SESSION的token方式，CSRF防御不会被XSS等漏洞绕过，因为XSS等漏洞不能操作Session。
- 既然token也会被绕过为什么不直接用Referer验证呢？毕竟Referer验证的的开发量相对于token模式会小一点。
- CSRF的防御手段(除了SESSION)目前在有XSS组合利用情况下都可以被绕过(XSS和CSRF同域的情况下)。